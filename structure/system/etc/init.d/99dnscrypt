#!/system/bin/sh

# /etc/init.d/99dnscrypt: start and stop the dnscrypt daemon
NAME=dnscrypt-proxy
DAEMON=/system/xbin/$NAME
DESC="DNSCrypt client proxy"
PIDFILE=/data/local/tmp/dnscrypt-proxy.pid
LOCKFILE=/data/local/tmp/dnscrypt-proxy.lock
CONFIG_FILE=/system/etc/dnscrypt-proxy/dnscrypt-proxy.toml
WAITFORDAEMON=30
DAEMON_ARGS=


. /system/etc/dnscrypt-proxy/iptables-rules

# Exit if the package is not installed
test -x $DAEMON || exit 0

log_info_msg () {
	echo "$NAME: $@" || true
	log -p i -t $NAME "$@" || true
}

log_error_msg () {
	echo "$NAME: $@" || true
	log -p e -t $NAME "$@" || true
}

pidofproc () {
	if [ -n "${PIDFILE:-}" ] || [ -e "$PIDFILE" ]; then
   	if [ -r "$PIDFILE" ]; then
			read pid < "$PIDFILE"
   		if [ -n "${pid:-}" ]; then
   			if $(kill -0 "${pid:-}" 2> /dev/null); then
         		return 0
   			elif ps "${pid:-}" >/dev/null 2>&1; then
					return 0 # program is running
      		else
      			return 1 # program is dead and pid file exists
     			fi
   		fi
      fi
   fi
   
   if ! ps | grep $NAME; then
   	return 1 # program is not running
	fi
	
	return 2
}


wait_for_daemon () {
	pid=$1
	sleep 1
	if test -n "$pid"
	then
		if ! kill -0 $pid 2>/dev/null
		then
			cnt=0
			while ! kill -0 $pid 2>/dev/null ; do
				cnt=`expr $cnt + 1`
				if [ $cnt -gt $WAITFORDAEMON ]
				then
					log_info_msg "$NAME still not running"
					return 1
				fi
				sleep 1
				[ "`expr $cnt % 3`" != 2 ] || log_info_msg "..."
			done
		fi
	fi
	return 0
}

case "$1" in
  start)
	if test ! -s "$CONFIG_FILE"; then
		log_info_msg "missing config file $CONFIG_FILE"
		exit 0
	fi
	
	if test -s "$LOCKFILE"; then
		log_info_msg "network first returned no response, running in fallback mode"
		ipv4_addr_unlock && rm $LOCKFILE
		
		$0 restart
		exit 1
	fi
	
	status="0"
	pidofproc >/dev/null || status="$?"
	
	if [ "$status" = 0 ]; then
		log_info_msg "already running"
		exit 0
	else
		log_info_msg "starting $DESC"
		
		setsid $DAEMON -config $CONFIG_FILE -- $DAEMON_ARGS \
			-pidfile=$PIDFILE </dev/null > /dev/null 2>&1 &
		pid=$! && echo $pid > $PIDFILE
		
		if wait_for_daemon $pid
		then
			log_info_msg "enabling iptables firewall rules"
			do_iptables_rules 0
		else
			log_error_msg "iptables didn't apply rules"
			ipv4_addr_lock && echo "ipv4-enabled=false" >> $LOCKFILE
			exit 1
		fi
	fi
	;;
	
  restart|force-reload|reload)
	# nothing to do
		$0 stop
		sleep 1
		$0 start
	;;
	
  stop)
	status="0"
	pidofproc >/dev/null || status="$?"
	
	if [ "$status" = 0 ]; then
		log_info_msg "stopping $DESC $NAME"
		pid=`cat $PIDFILE 2>/dev/null` || true
		
		if kill $pid 2>/dev/null; then
			log_info_msg "disabling iptables firewall rules"
			do_iptables_rules 1
		else 
			log_info_msg "Is $pid not $NAME? Is $DAEMON a different binary now?"
		fi
		
		rm $PIDFILE
	elif [ "$status" = 2 ]; then
		log_info_msg "not running - there is no $PIDFILE"
		killall $NAME >/dev/null 2>&1
		
		exit 1
	fi
	;;
	
  status)
	status="0"
	pidofproc >/dev/null || status="$?"
	
	if [ "$status" = 0 ]; then
      log_info_msg "$NAME is running"
	elif [ "$status" = 1 ]; then
		log_info_msg "$NAME is not running"
	else
		log_error_msg "could not access PID file (`cat $PIDFILE`) for $NAME"		
	fi
	
	exit $status
	;;
	
  *)
	echo "Usage: $0 {start|stop|restart|force-reload|reload|status}" >&2
	exit 3
	;;
esac

exit 0